<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<link rel="alternate"
      type="application/rss+xml"
      href="https://www.birkey.co/rss.xml"
      title="RSS feed for https://www.birkey.co/"/>
<title>BirkeyCo</title>
<meta name="author" content="Kasim Tuman">
	       <meta name="referrer" content="no-referrer">
	       <link href= "static/style.css" rel="stylesheet" type="text/css" />
	       <link rel="icon" href="static/favicon.ico">
	       <link rel="apple-touch-icon-precomposed" href="static/birkey_logo.png">
	       <link rel="msapplication-TitleImage" href="static/birkey_logo.png">
	       <link rel="msapplication-TitleColor" href="#0141ff">
	       <link rel="alternate" type="application/rss+xml"  title="RSS Feed for birkey.co" href="/rss.xml"
	       <meta http-equiv="content-type" content="application/xhtml+xml; charset=UTF-8">
	       <meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1"></head>
<body>
<div id="preamble" class="status"><br><center>
      <div style="display: inline-block; vertical-align:middle;">
  <a href="https://www.birkey.co/index.html" style="text-decoration: none;"><b>KASIM TUMAN'S WEBSITE</b><br>
  </a><hr/><div style="text-align: justify;display: inline-block; width: 100%;">
  <a class="title" href="https://www.birkey.co/resume/resume.html">ABOUT</a> &nbsp;<a class="title" href="https://github.com/oneness">GITHUB</a> &nbsp;<a class="title" href="https://www.birkey.co/rss.xml">RSS</a> &nbsp;<a class="title" href="https://www.birkey.co/archive.html">ARCHIVE</a> &nbsp;<a class="title" href="https://paypal.me/ktuman">DONATE</a></div></div>
  </center><br><br>
  <div style="margin-bottom: 3ch;text-transform: none;">
  </div>
  <div class='heading'>Kasim Tuman's Website</div><hr/>
  <p>This is my personal website. You can find here my codes and ideas about programming. </p></div>
<div id="content">

<div class="post-date">10 Mar 2020</div><h1 class="post-title"><a href="https://www.birkey.co/2020-03-10-one-command-to-drive-all.html">One command to drive all</a></h1>
<p>
Over the years, I got to learn various package managers either due to tinkering with work or home infrastructure. I need to keep remembering if I am on Ubuntu, OSX or on OpenBSD if I want to install/remove/list/update packages. wouldn&rsquo;t it be nice if all I need to remember is just one command <b>pkg</b> with following neumonic options?
</p>
<ul class="org-ul">
<li><b>s</b> for searching for a package</li>
<li><b>i</b> for install a package</li>
<li><b>r</b> for removing a package</li>
<li><b>l</b> for listing installed packages</li>
<li><b>c</b> for checking/cleaning packages</li>
</ul>

<p>
Following shell script does exactly that. And it could also serve as your reference to all unix package managers as an added benefit.
</p>
<div class="org-src-container">
<pre class="src src-Shell">#!/bin/sh
# One pkg command to rule them all
if [ -z "$1" ]
then
    echo "Usage: pkg &lt;i(nstall)|r(emove)|s(earch)|u(pdate)|l(ist)&gt;"
else
    os=$([[ -f /etc/os-release ]] &amp;&amp; grep ^ID= /etc/os-release | cut -d = -f 2 || echo `uname`)
    echo --------------------- $os --------------------
    command=$1
    shift
    case $os in
	*OpenBSD*)
	    case $command in
		i)
		    pkg_add $@
		    ;;
		r)
		    pkg_delete $@
		    ;;
		s)
		    pkg_info -Q $@
		    ;;
		u)
		    pkg_add -u $@
		    ;;
		l)
		    pkg_info -mz
		    ;;
		c)
		    pkg_check
		    ;;
	    esac
	    ;;
	*Arch)
	    case $command in
		i)
		    yay -S $@
		    ;;
		r)
		    yay -Rs $@
		    ;;
		s)
		    yay -Ss $@
		    ;;
		u)
		    yay -Syyu $@
		    ;;
		l)
		    yay -Q $@
	    esac
	    ;;
	*solus*)

	    case $command in
		i)
		    sudo eopkg it $@
		    ;;
		r)
		    sudo eopkg remove $@
		    ;;
		s)
		    sudo eopkg search $@
		    ;;
		u)
		    sudo eopkg up
		    ;;
		l)
		    sudo eopkg list-installed
	    esac
	    ;;
	VoidLinux)
	    case $command in
		i)
		    sudo xbps-install $@
		    ;;
		r)
		    sudo xbps-remove -R $@
		    ;;
		s)
		    sudo xbps-query -Rs $@
		    ;;
		u)
		    sudo xbps-install -Su
		    ;;
		l)
		    sudo xbps-query -l
		    ;;
		c)
		    sudo xbps-remove -Oo
		    ;;
	    esac
	    ;;
	pureos|PureOS|debian|Ubuntu)
	    case $command in
		i)
		    sudo apt-get install $@
		    ;;
		r)
		    sudo apt-get remove $@
		    ;;
		s)
		    apt-cache search $@
		    ;;
		u)
		    sudo apt-get update &amp;&amp; sudo apt-get upgrade
		    ;;
		l)
		    sudo apt list --installed
		    ;;
		c)
		    sudo apt-get autoremove
		    ;;
	    esac
	    ;;
	darwin*|Darwin*)
	    case $command in
		i)
		    brew install $@
		    ;;
		r)
		    brew remove $@
		    ;;
		s)
		    brew search $@
		    ;;
		u)
		    brew update
		    ;;
		l)
		    brew list
		    ;;
		c)
		    brew cleanup
		    ;;
	    esac
	    ;;
	*)
	    echo "Unknown OS. Please add it to $(basename "$0") pkg function"
    esac
fi
</pre>
</div>

<p>
If you happen to use Emacs and Eshell, you can just use following alias to get going:
</p>
<div class="org-src-container">
<pre class="src src-Shell">alias pkg ./pkg '$*'
</pre>
</div>
<p>
Eshell aliases are great. You can pass arguments to them just prefixing aliases with &rsquo;$*&rsquo; as I did above. Try doing same with bash alias, you are out of luck and you have to write shell functions be able to do that. Enjoy!
</p>
<div class="taglist"><a href="https://www.birkey.co/tags.html">Tags</a>: <a href="https://www.birkey.co/tag-shell.html">shell</a> </div>
<div class="post-date">05 Mar 2020</div><h1 class="post-title"><a href="https://www.birkey.co/2020-03-05-self-documenting-makefile.html">Self documenting Makefile</a></h1>
<p>
One of the pain points of starting a new project or even hacking on existing project is to know where to start. One can start with documentation, test cases or even running it to see the logs and stacktraces (Stracktrace way is one of my favourite and you can tell a lot about code flow, organzation and you can even find un-handled bugs that way, which is a topic of its own for a blog post). Each language brings in its own set of tools that you need to know before you getting familiar with the code base. You might add `README` or some other documents to ease the pain but it might get stale overtime. One convention that I have been using, which has paid off with any project or teams that I have collaborated, are following simple conventions:
</p>
<ul class="org-ul">
<li>Each Project Should have a `Makefile` with following targets:
<ul class="org-ul">
<li><b>setup</b> : Should take care of env configs</li>
<li><b>deps</b>  : Should take care of handling all the project dependencies</li>
<li><b>unit-test</b> : Should have local tests</li>
<li><b>integration-test</b> : Should have non local tests</li>
</ul></li>
<li>This Makefile should be self documenting:
<ul class="org-ul">
<li>It should have <b>help</b> as the default target that explains what the project is about and how to run it</li>
<li>It should be self documenting, meaning each target should have it is own description as to what it does and possible why it does it the way it is.</li>
</ul></li>
</ul>

<p>
Above might sound a lot to ask but it is really trivial to do those with just following make file:
</p>

<div class="org-src-container">
<pre class="src src-Shell">.PHONY: help
help: ## This is a cool project. It does great things to help humanity move forward.
	@echo 'usage: make [target] ...'
	@echo
	@echo 'Targets Depends Description' | column -t -s ' '
	@echo '------- ------- -----------' | column -t -s ' '
	@egrep '^(.+)\:?.+\ ##\ (.+)' ${MAKEFILE_LIST} \
	| column -t -s ':#' | sed 's/Makefile  //'

setup: ## Sets up all that are needed start working on the project.
	@echo Setting up...
	# Put you logic here
	@echo Setting up done.

deps: setup ## Pulls in all required dependencies
	@echo Pulling all project dependencies

unit-test: deps ## Runs local tests
	@echo Running unit-tests...
	# Put your run unit-tests logic here
	@echo unit-tests done.

integration-test: deps ## Runs non local tests
	@echo Running integration-tests...
	# Put your run integration-tests logic here
	@echo integration-tests done.
</pre>
</div>

<p>
The presence of above Makefile should not be underestimated. It will allow yourself and your fellow developers to dive into any project with just one liner like this:
</p>

<div class="org-src-container">
<pre class="src src-Shell">git clone &lt;project&gt; &amp;&amp; cd project &amp;&amp; make deps
</pre>
</div>

<p>
Would not that be wonderful if every project just follow simple conventions like this so you have less obstacle to start or dive into a project? It has benefited me and my team over the years and hope you see the benefit for yourself.
</p>
<div class="taglist"><a href="https://www.birkey.co/tags.html">Tags</a>: <a href="https://www.birkey.co/tag-makefile.html">Makefile</a> </div>
<div class="post-date">15 Feb 2020</div><h1 class="post-title"><a href="https://www.birkey.co/2020-02-15-openbsd-laptop-for-the-paranoid.html">OpenBSD laptop for the paranoid</a></h1>
<p>
<b>Disclaimer</b>: This is not a post about UNIX variants flame war. It is not my intention to recruit OpenBSD converts either as no one has influenced me to switch to it after 10 years of distro hopping. The main reasons I am using OpenBSD as my daily driver on both of my laptops (Thinkpad X220 and XPS 13 9365) are: <b>Security</b>, <b>Stability</b>, and <b>Frugality</b>.
</p>
<div id="outline-container-org1d64a75" class="outline-2">
<h2 id="org1d64a75">Security</h2>
<div class="outline-text-2" id="text-org1d64a75">
<p>
I am software generalist who knows enough about system (OS,Network and Application) security to be paranoid not just about online systems, which is far from enough to keep ourselves secure, but also on-prem system such as Operating Systems we all rely on for keeping us safe. While Linux could be made as secure as OpenBSD after much tinkering and tweaking, OpenBSD is more secure by default installation. Following quote from <a href="https://www.openbsd.org/">https://www.openbsd.org/</a> is very telling:
</p>
<blockquote>
<p>
Only two remote holes in the default install, in a heck of a long time!
</p>
</blockquote>
<p>
That quote is for what OpenBSD team calls base file set that includes the kernel and base system. Security is the utmost priority for packages being included in the port tree as well. For example, Chromium comes with `&#x2013;enable-unveil` support, which means that it can only access `~/Downloads` folder to mitigate the attack surface if your browser ever gets hijacked.
</p>
</div>
</div>
<div id="outline-container-orgef236bd" class="outline-2">
<h2 id="orgef236bd">Stability</h2>
<div class="outline-text-2" id="text-orgef236bd">
<p>
OpenBSD favors stability over new features. Once installed and configured to your liking, it just stays out of your way allowing you focus on your task at hand. You will not see nagging notifications demanding you to click on installing updates. You can just setup a cron to run `syspatch` to bring in security fixes whenever and however you like. Releases are scheduled for every 6 months in a predictable way so you are in control to plan it ahead. I am running 6.6 release and following errata proves my point: <a href="https://www.openbsd.org/errata66.html">https://www.openbsd.org/errata66.html</a>
</p>
</div>
</div>
<div id="outline-container-org2b9bb12" class="outline-2">
<h2 id="org2b9bb12">Frugality</h2>
<div class="outline-text-2" id="text-org2b9bb12">
<p>
Wikipedia has the best definition for this and I believe it genuinely applies to the Philosophy of OpenBSD project. `Less is more` is a pretty well known Unix tradition and the command `less` (which is a replacement of early UNIX command `more`) is seen in every UNIX variants. OpenBSD is not the most user friendly Unix out there not even among BSD flavors. It is targeted towards security and resource savvy power users who wants have control over every piece of software running on their system. Every line of code is audited for frugality and not needed code is removed. Development is not driven by any cooperate or financial interest as apposed to the Operating System development from big Corporations such as Microsoft, Apple and Google. You can use your old hardware as long as it meets your needs and will not find yourself at the mercy of them nagging you upgrade your hardware let alone your system so often.
</p>

<p>
All in all, it gives you a piece of mind compared to any OS out there when it comes to knowing you are safe by default. If you would like to know more about why OpenBSD, you can visit this site for technical details:
<a href="https://why-openbsd.rocks/fact/">https://why-openbsd.rocks/fact/</a>
</p>

<p>
I am currently running OpenBSD 6.6 on Thinkpad X220 (everything work out of the box) and Dell XPS 13 2 in 1 9365 (all works except for suspend - same as some leading Linux distros). The installation process is not that complicated (mostly you just except the default prompt by hitting enter) but does need some config to make it to your liking. I might blog about the installation process and list my configs for `X` and `cwm` in the future.
</p>
</div>
</div>
<div class="taglist"><a href="https://www.birkey.co/tags.html">Tags</a>: <a href="https://www.birkey.co/tag-openbsd.html">OpenBSD</a> </div>
<div class="post-date">07 Sep 2019</div><h1 class="post-title"><a href="https://www.birkey.co/2019-09-07-atreus62---best-portable-mechanical-keyboard.html">Atreus62 - Best portable mechanical keyboard</a></h1>
<p>
As a professional programmer, we spend a lot of time with our
keyboards. Having a good ergonomic keyboard is extremely important to
avoid RSI. Since I started learning more about mechanical and
ergonomic keyboards couple of years ago, I have experimented with many
of them - different models, layouts, and switches. Finally, I settled
down with following two: 
</p>
<ul class="org-ul">
<li><a href="https://kinesis-ergo.com/shop/advantage2/">Kinesis Advantage2</a></li>
<li><a href="https://shop.profetkeyboards.com/product/atreus62-keyboard">Profet Atreus62</a></li>
</ul>

<p>
Kinesis one needs couple of weeks to get used as apposed to the Profet
Atreus62 one, which took me few hours. They both uses brown switches,
Kinesis uses Cherry brown, Atreus62 uses Gateron brown. While there
are differences in terms of the point of actuation, peak and tactile
noise based on their spec, I personally did not feel strongly enough
to tell the difference so your mileage may vary. Both of them are very
easy to configure to your liking. Kinesis have done a great job when
it comes to how key mapping is done. Here is how you do it:
</p>
<ul class="org-ul">
<li>Just press both `progm` + F12 together to have it enter remap mode</li>
<li>Then, press the source key you want to move, release it, then press the
destination key that you want to have the source key moved.</li>
<li>Press `progm` to return to normal mode (exits from remap mode).</li>
</ul>

<p>
Atreus62 is a bit involved but it is a joy to hack on it. It uses open
source firmware called `QMK` and you can read more about it here:
<a href="https://docs.qmk.fm/#/">https://docs.qmk.fm/#/</a>. The documentation is great and strongly
recommend you check them out. It is a bit overwhelming and you could
get lost among so much details. The easiest way to start configuring
are to follow these steps:
</p>
<ul class="org-ul">
<li>Go to <a href="https://config.qmk.fm/#/atreus62/LAYOUT">https://config.qmk.fm/#/atreus62/LAYOUT</a> and shuffle keys
around to your liking.</li>
<li>Then download `KEYMAP ONLY`, which gives you `keymap.c`,
`layers.json` and `readme.md`.</li>
<li>Unzip them to a folder say `MyAtreus62Layout`.</li>
<li>Clone QMK Firmware: <a href="https://github.com/qmk/qmk_firmware/">https://github.com/qmk/qmk_firmware/</a></li>
<li>Once cloned, run `./util/qmk-install.sh` from within cloned folder.</li>
<li>Copy `MyAtreus62Layout` folder into `/keyboards/atreus62/keymaps/`
folder within the cloned folder.</li>
<li>Run `make atreus62:MyAtreus62Layout`.</li>
<li>It will generate `atreus62<sub>MyAtreus62Layout.hex</sub>` firmware file.</li>
<li>Use qmk-toolbox GUI found here:
<a href="https://github.com/qmk/qmk_toolbox/releases/">https://github.com/qmk/qmk_toolbox/releases/</a> to flash the firmware.</li>
</ul>

<p>
<b>NOTE:</b> Remember to put your keyboard in flash mode by pressing a thin
paper clip through a tiny hole on the back of the keyboard. 
</p>

<p>
One you go through, above process, you will easily find that editing
the `keymap.c` file is the easiest way to arrange keys. All you need
is the key codes that you can find on the online GUI layout
editor. Once you edit keymap files using your favorite editor, save it
and run the above make command to generate the firmware to flash
it. You can also version control the keymap files in case you want to
share or change it later. Here is my layout if you are curious:
<a href="https://drive.google.com/open?id=1M6x73xg2kAfkL8AvSM31X8MpW3pPlXcX">https://drive.google.com/open?id=1M6x73xg2kAfkL8AvSM31X8MpW3pPlXcX</a>
</p>
<div class="taglist"><a href="https://www.birkey.co/tags.html">Tags</a>: <a href="https://www.birkey.co/tag-keyboard.html">keyboard</a> </div>
<div class="post-date">04 Aug 2019</div><h1 class="post-title"><a href="https://www.birkey.co/2019-08-04-why-emacs.html">Why Emacs</a></h1>
<p>
I have been thinking about writing up my experience of using Emacs and
its positive influence on me as a Software Craftsman over the last 10
years or so. Over the weekend, I came across a a blog post by the CTO
of a company, who put it very well that have really resonated with
me. It is a great read, not too long not too short, that I strongly
recommend you go ahead read and come back here to continue with the
rest of what I had to say. Here is the link: <a href="https://www.fugue.co/blog/2018-08-09-two-years-with-emacs-as-a-cto.html">Two Years With Emacs as a
CEO (and now CTO)</a>. 
</p>

<p>
So I am not going to repeat what he said about Emacs and why he still
loves to use it to get things done. I am going to add following points
on top of what he wrote there:
</p>
<div id="outline-container-org772d81f" class="outline-2">
<h2 id="org772d81f">Emacs is a great workbench</h2>
<div class="outline-text-2" id="text-org772d81f">
<p>
I see Emacs as an extremely well designed workbench that will evolve
with you as your work environment, technology and paradigms
change. Emacs is a live programming environment where you can change
every aspects of its functionalities, be it a simple text editing to a
complex work flow where you can interact with many external
systems. One of a startup that I worked had a mode where we have
interacted with our live system written in Clojure via its CLI
interface using `comint-mode`, which you should really checkout if you
are not familiar with it. You can use Emacs as the client with uniform
interface to many of the CLI, API and even for <a href="https://en.wikipedia.org/wiki/Application_binary_interface">ABI</a>. For example `EXWM`,
which is an Window Manager, is a great example.
</p>
</div>
</div>
<div id="outline-container-orgbd986d6" class="outline-2">
<h2 id="orgbd986d6">Emacs is a great structured and unstructured text manipulation library</h2>
<div class="outline-text-2" id="text-orgbd986d6">
<p>
This is what I personally like a lot about Emacs. As a programmer, we
work with manipulating text all the time. Yes, there are great text
Editors out there, which by the way I have used all of them myself
before seeing the light of using Emacs. But I see all other
editors/IDEs as a framework for the things they set out to do rather
than a library that I can compose to solve a particular problem at
hand. For example, I can use `smartparens` package for structured text
editing of Clojure code.
</p>
</div>
</div>
<div id="outline-container-org61747c1" class="outline-2">
<h2 id="org61747c1">Emacs helps you focus</h2>
<div class="outline-text-2" id="text-org61747c1">
<p>
In this day of our age where everything tries to grab your constant
attention, Emacs stands out as the most distraction free environment
to be in. One might argue that Emacs user spends way more time
configuration management, which is definitely true when you are just
getting started with any new toolbox, I found I spend very little time
with configuration or keeping it up to date. Once you are familiar with
Emacs help system and built in Documentation, You can be pretty much
on your own when it comes to how much you spend on customization. It
is this freedom you get from using Emacs where you are in charge as to
how much customization you would like. The reason I say Emacs helps
you focus is due to the fact that you have the freedom to make it an
distraction free writing/coding/communication environment to get done
what matters the most to you and have a lot of fun along the way.
</p>
</div>
</div>
<div id="outline-container-org76e90eb" class="outline-2">
<h2 id="org76e90eb">Emacs has a learning curve</h2>
<div class="outline-text-2" id="text-org76e90eb">
<p>
Yes, I do acknowledge that Emacs has a learning curve. However, most
of it is due to the wrong approach we tend to take when encountering an
unknown. On hindsight, I wish I had following approach, which I do now
all the time:
</p>
<ol class="org-ol">
<li>Start with getting familiar with Emacs terminology such as windows,
buffers and frames etc. The builtin documentation is great for that
and it is just C-h i (Hit Control and letter `h` at the same time,
then hit `i`, which stands for info). To read Emacs&rsquo; manual just
enter `m` and select `Emacs` from minibuffer. Hmm, you might be
wondering what is minibuffer, let us use this approach to find
out. Press following C-h i m key sequence and type `Minibuffer` and
hit enter. Voila, you are reading all about `Minibuffer` from the
official Emacs manual. No other application that I have used comes
close to the level of Emacs in terms of self documentation.</li>
<li>Start with the goal of getting something done. I have two example
that every programmer will benefit from learning: `Magit` and
`Org-mode`. While you need to install `magit-mode`, which is a
Emacs interface to git CLI, `org-mode` is built in. You will be
surprised to find that it makes your git journey so much fun or
your note organization so much enjoyable. I made the mistake of
trying to memorize hot keys as much as I can before learning the
hard truth of learning one key at a time as needed bases. I
strongly recommend the only hot key you need at the beginning is
`M-x`, where you just type a command so Emacs can execute for
you. For Example, if you would like open (it is `visit` in Emacs
speak) a file, just type `M-x` and type `file` then press tab key,
select `find-file` in the completion buffer, now you can choose a
file name from within the directory that you are in. It is just an
example but knowing the fact that every action you perform in Emacs
invokes an command, which is just an elisp function, is a very
powerful realization. That means you can write an elisp function to
have Emacs do whatever you like. You can also lookup what a command
does using C-h f, then typing the name of the command. For example,
C-h f then, type `org-insert-link` then enter and read on&#x2026;</li>
<li>I advise against starting with Emacs using other&rsquo;s configuration
including Emacs that comes with pre-configuration. As I have
mentioned earlier, Emacs is a great library where you can pick and
choose to fit your work style. You will loose this great aspects if
you start with other&rsquo;s way of configuring/composing it. If you had
to just start with a minimal config, put this in your `init.el`
file and start changing/adding/organizing configs as you see
fit. For example:</li>
</ol>
<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #b22222;">;; </span><span style="color: #b22222;">Emacs reads init.el file located in ~/.emacs.d at startup</span>
<span style="color: #b22222;">;; </span><span style="color: #b22222;">bootstrap el-get</span>
<span style="color: #7f7f7f;">(</span>add-to-list 'load-path <span style="color: #8b2252;">"~/.emacs.d/el-get/el-get"</span><span style="color: #7f7f7f;">)</span>
<span style="color: #7f7f7f;">(</span><span style="color: #a020f0;">unless</span> <span style="color: #7f7f7f;">(</span><span style="color: #a020f0;">require</span> '<span style="color: #008b8b;">el-get</span> nil 'noerror<span style="color: #7f7f7f;">)</span>
  <span style="color: #7f7f7f;">(</span><span style="color: #a020f0;">with-current-buffer</span>
      <span style="color: #7f7f7f;">(</span>url-retrieve-synchronously
       <span style="color: #8b2252;">"https &#59833;/raw.githubusercontent.com/dimitri/el-get/master/el-get-install.el"</span><span style="color: #7f7f7f;">)</span>
    <span style="color: #7f7f7f;">(</span>goto-char <span style="color: #7f7f7f;">(</span>point-max<span style="color: #7f7f7f;">))</span>
    <span style="color: #7f7f7f;">(</span>eval-print-last-sexp<span style="color: #7f7f7f;">)))</span>

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Initialize available packages first</span>
<span style="color: #7f7f7f;">(</span>package-refresh-contents t<span style="color: #7f7f7f;">)</span>

<span style="color: #b22222;">;; </span><span style="color: #b22222;">The only package you need to get started</span>
<span style="color: #7f7f7f;">(</span><span style="color: #a020f0;">el-get-bundle</span> smex
  <span style="color: #7f7f7f;">(</span><span style="color: #a020f0;">progn</span>
    <span style="color: #7f7f7f;">(</span><span style="color: #a020f0;">require</span> '<span style="color: #008b8b;">smex</span><span style="color: #7f7f7f;">)</span>
    <span style="color: #7f7f7f;">(</span>global-set-key <span style="color: #7f7f7f;">(</span>kbd <span style="color: #8b2252;">"M-x"</span><span style="color: #7f7f7f;">)</span> 'smex<span style="color: #7f7f7f;">)))</span>
</pre>
</div>
<p>
Above snippets sets you up to use `El-get`, a great package manager
that I came to rely over the years and have never failed me. It also
pulls in the only package you had to have before getting started,
`smex` that makes the only command `M-x` you need much more
intuitive. Then say if you want to try `magit`, just type M-x
el-get-install, then `magit`. El-get will download it and install it
so you can starting using it in your git projects. Once you can find
your way around Emacs, you can start your journey of how best
organize your config/customization as you go along. I use just one
org file for it and you might or might not like it. Here is the file
in its entirety if you are interested: <a href="./static/config.html">My config snapshot</a>
</p>
</div>
</div>
<div class="taglist"><a href="https://www.birkey.co/tags.html">Tags</a>: <a href="https://www.birkey.co/tag-emacs.html">emacs</a> </div><div id="archive">
<a href="https://www.birkey.co/archive.html">Other posts</a>
</div>
</div>
<div id="postamble" class="status"><br><center>
      <div style="display: inline-block; vertical-align:middle;"></div></div>
</body>
</html>
