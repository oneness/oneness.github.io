<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<link rel="alternate"
      type="application/rss+xml"
      href="https://www.birkey.co/rss.xml"
      title="RSS feed for https://www.birkey.co/">
<title>BirkeyCo</title>
<link href="static/style.css" rel="stylesheet" type="text/css" />
	   <link rel="apple-touch-icon" sizes="180x180" href="static/apple-touch-icon.png">
	   <link rel="icon" type="image/png" sizes="32x32" href="static/favicon-32x32.png">
	   <link rel="icon" type="image/png" sizes="16x16" href="static/favicon-16x16.png">
	   <link rel="manifest" href="/site.webmanifest">
	   <link rel="mask-icon" href="static/safari-pinned-tab.svg" color="#5bbad5">
	   <link rel="alternate" type="application/rss+xml" title="RSS Feed for birkey.co" href="/rss.xml">
	   <meta name="author" content="Kasim Tuman">
	   <meta name="referrer" content="no-referrer">
	   <meta name="msapplication-TileColor" content="#da532c">
	   <meta name="theme-color" content="#ffffff">
	   <meta http-equiv="content-type" content="application/xhtml+xml; charset=UTF-8">
	   <meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1">
	  </head>
<body>
<div id="preamble" class="status"><br><center>
       <div style="display: inline-block; vertical-align:middle;">
  <a href="https://www.birkey.co/index.html" style="text-decoration: none;"><b>BIRKEY CONSULTING</b><br>
  </a><hr/><div style="text-align: justify;display: inline-block; width: 100%;">
<a class="title" href="https://github.com/oneness">ABOUT</a> &nbsp;<a class="title" href="https://www.birkey.co/rss.xml">RSS</a> &nbsp;<a class="title" href="https://www.birkey.co/archive.html">ARCHIVE</a></div></div>
  </center><br><br>
  <div style="margin-bottom: 3ch;text-transform: none;"></div></div>
<div id="content">
<h1 class="title">Posts tagged "nix":</h1>
<div class="post-date">15 Apr 2025</div><h1 class="post-title"><a href="https://www.birkey.co/2025-04-15-nix:-better-way-for-fun-and-profit.html">Nix: Better way for fun and profit</a></h1>
<p>
Nix is started in 2003 as a research project aimed to solve the
problem of <b>reliable software deployment</b>. The PhD thesis titled <b>The
Purely Functional Software Deployment Model</b> proposed a novel way of
building software where the final artifact is purely dependent on the
inputs to the build system, which is a pure function in a mathematical
sense. Regardless of where you are in your nix journey, I can't
recommend this paper (<a href="https://edolstra.github.io/pubs/phd-thesis.pdf">thesis</a>) enough. It is very approachable and
worth a read so you learn from first principle of what, why and how
about Nix.
</p>

<p>
Nix is a software build and management system that can replace
traditional package managers, build environments and configuration
tools. Due to the inherent complexity of the problem domain nix is
designed to solve and its long history, it has pretty steep learning
curve but not unsurmountable. One of the common point of confusions is
how the term `Nix` is used in documentations, tutorials and
blogosphere. So let me clarify few terminologies that often gets
overloaded. 
</p>

<ul class="org-ul">
<li><b>Nix:</b> Unless otherwise fully qualified, I use it to mean the
software build and management system.</li>
<li><b>Nix CLI:</b> The nix command line client that one uses to interact with nix.</li>
<li><b>Nix DSL:</b> The domain specific language that nix uses to generate a
software package. I would like to see everyone start using it to
mean the nix language.</li>
<li><b>Flakes:</b> A Nix DSL with number of conventions that is designed to
ease the configuration and discoverability of software packaging lifecycle.</li>
<li><b>NixOS:</b> The final artifact, which is happened to be a Linux
Operating System that is generated by feeding Nix DSL to nix. I will
not be covering it in this blog post.</li>
</ul>

<p>
After few false starts and restarts, below are what I believe to be
better ways for getting started, using nix for fun and profit.
</p>
<div id="outline-container-org2f32676" class="outline-2">
<h2 id="org2f32676">Installation</h2>
<div class="outline-text-2" id="text-org2f32676">
<p>
I have a following bash script to install a specific version so I can
have control over which version to install, what features enable and
disable.
</p>

<div class="org-src-container">
<pre class="src src-bash">#!/usr/bin/env bash
set -Eeuo pipefail

VERSION='2.28.1' # replace it with the latest version
URL="https://releases.nixos.org/nix/nix-${VERSION}/install"
MY_CONF="$HOME/.dotfiles/nix/nix.conf"
sh &lt;(curl --location "${URL}") \
     --daemon \
     --no-channel-add \
     --nix-extra-conf-file ${MY_CONF}
# conf file has this content
experimental-features = nix-command flakes
</pre>
</div>
<p>
The `&#x2013;no-channel-add` and the extra conf file needs some
explanation. Nix called a remote url a channel that gets automatically
installed, where nix uses to retrieve package definitions (Nix DSL) to
manage packages. It introduces a state, which is currently installed
channel url that is outside of Nix DSL, thus defeating the purpose of
reproducibility. It is considered legacy feature and not needed by
flakes, an experimental feature already widely adopted by the
community. So I highly recommend enabling flakes and additional
commands to interact with it.
</p>
</div>
</div>
<div id="outline-container-org2b5adb4" class="outline-2">
<h2 id="org2b5adb4">Using for fun and sanity</h2>
<div class="outline-text-2" id="text-org2b5adb4">
<p>
Every project depends on existing software that is beyond your
control. Nix DSL enables you to declaratively specify your projects
dependencies, a repo or a tar-ball down to the file digest of its
content, which is what gives nix superpowers of being a deterministic
and reproducible package manager. This means that if your inputs stays
the same, nix guarantees that it produces the exact same output
regardless of when and where. Below is a flake that pulls in latest
version of Clojure into your project.
</p>

<div class="org-src-container">
<pre class="src src-nix">{
  # optional attribute
  description = "My awesome Clojure/ClojureScript project";

  # required attribute
  inputs = {
    # nix dsl fns useful for writing flakes
    flake-utils.url = "github:numtide/flake-utils/v1.0.0";
    # Pins state of the packages to a specific commit sha
    pinnedPkgs.url = "github:NixOS/nixpkgs/c46290747b2aaf090f48a478270feb858837bf11";
  };

  # required attribute
  outputs = { self, flake-utils, pinnedPkgs }@inputs :
  flake-utils.lib.eachDefaultSystem (system:
  let pinnedSysPkgs = inputs.pinnedPkgs.legacyPackages.${system};
  in
  {
    devShells.default = pinnedSysPkgs.mkShell {
      packages = [
        pinnedSysPkgs.clojure
      ];

      # commands to run in the development interactive shell
      shellHook = ''
        echo To get Clojure REPL, Run:
        echo clojure
        echo To get ClojureScript REPL, Run:
        echo clj -Sdeps \'{:deps {org.clojure/clojurescript {:mvn/version "1.11.132"}}}\' -M -m cljs.main --repl
      '';
    };
    packages = {
      docker = pinnedSysPkgs.dockerTools.buildLayeredImage {
        name = "My awesome Clj docker image built by nix";
        tag = "latest";
        contents = [pinnedSysPkgs.clojure];
      };
    };
  });
}

</pre>
</div>

<p>
Do not worry too much about not understanding above nix dsl code. The
most important thing to know is that it is nix dsl referred to as a
flake that specifies its inputs and outputs declaratively. Save above
code as `flake.nix`, which is a convention, then run `nix develop` to
get an interactive shell with Clojure in your path. Nix can do way
more than this. However, I recommend you just start with solving
project dependencies problem. Above flake gives you following
benefits:
</p>
<ul class="org-ul">
<li>Ability to pin the exact versions of your project dependencies.</li>
<li>Cross platform development environment that works
both in MacOS and various flavors of Linux.</li>
<li>Determinate and reproducible development environment that
eliminates "it works on my machine" tooling issues.</li>
</ul>
<p>
One important thing to notice here is the way I chose to reference
the url inputs of the flake. I deliberately used tags or commit sha to
prevent the state of the urls (thus the state of the nix DSL) change
under me, which defeats the purpose of having a determinate
and reproducible way to get a development environment. I have
following bash script that prints available tags and corresponding
commit hash:
</p>
<div class="org-src-container">
<pre class="src src-bash"> git_tag_sha () {
   repo="$1"
   echo "********************************************************"
   echo "Available release and commit sha for pinning are:"
   echo "********************************************************"
   printf "\033[1m%-12s %s\033[0m\n" "release" "commit sha"
   curl -s https://github.com/$repo/tags | grep -oP 'href="\K[^"]*(releases/tag|nixpkgs/commit)[^"]*' | awk -F '/' 'NR%2{tag=$NF; next} {printf "%-12s %s\n", tag, $NF}'
   echo
   echo "****************************************************************************"
   echo "Please replace the commit sha of following line to pin pkgs to a commit sha: "
   echo "pinnedPkgs.url = github:$repo/&lt;commit&gt;"
   echo "****************************************************************************"
   echo
}
# You can run it like this:
 git_tag_sha "NixOS/nixpkgs"
</pre>
</div>
</div>
</div>
<div id="outline-container-orgec3469a" class="outline-2">
<h2 id="orgec3469a">Profiting in CI/CD and production</h2>
<div class="outline-text-2" id="text-orgec3469a">
<p>
This is probably one of the most frictionless and rewarding outcome of
using nix. Nix is designed to solve the problem of software deployment
after all but the wholesale adoption in production might prove to be
too much for the final gain. To spare yourself countless hours of
frustration, I highly recommend you start with using it to build
docker image if you happened to use docker and Kubernetes. Nix has
superb built-in support for making the smallest possible docker image
otherwise impossible. Above flake already includes `docker` image as
one of its packages output. Here is how you build and load the docker image:
</p>

<div class="org-src-container">
<pre class="src src-bash">nix build .#docker # the image will be in ./result
docker load &lt; ./result # to get it ready to be deployed
</pre>
</div>

<p>
It is a declarative way (using the power of Nix DSL compared to using
series commands in YAML file) to deterministically reproduce layered
Docker image that saves time and money in your DevOps journey. Have
fun and enjoy!
</p>
</div>
</div>
<div class="taglist"><a href="https://www.birkey.co/tags.html">Tags</a>: <a href="https://www.birkey.co/tag-nix.html">nix</a> </div><div id="archive">
<a href="https://www.birkey.co/archive.html">Other posts</a>
</div>
</div>
<div id="postamble" class="status"><br><center>
	      <div style="display: inline-block; vertical-align:middle;"></div></div>
</body>
</html>
